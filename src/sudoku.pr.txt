==============================================
block.cpp
==============================================
/*
 * block.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "block.h"
Block::Iterator::Iterator(Block& block, int blockRowNo, int blockColumnNo) :
                block(block),
                blockRowNo(blockRowNo),
                blockColumnNo(blockColumnNo) {
}
Block::Iterator::Iterator(const Iterator& iter) :
                block(iter.block),
                blockRowNo(iter.blockRowNo),
                blockColumnNo(iter.blockColumnNo) {
}
Block::Iterator Block::Iterator::operator++() {
    ++blockColumnNo;
    if (blockColumnNo == BLOCK_LENGTH) {
        blockColumnNo = 0;
        blockRowNo++;
    }
    return *this;
}
Block::Iterator Block::Iterator::operator++(int) {
    Iterator tmp(*this);
    ++blockColumnNo;
    if (blockColumnNo == BLOCK_LENGTH) {
        blockColumnNo = 0;
        blockRowNo++;
    }
    return tmp;
}
bool Block::Iterator::operator==(Iterator rhs) {
    return blockRowNo == rhs.blockRowNo && blockColumnNo == rhs.blockColumnNo;
}
bool Block::Iterator::operator!=(Iterator rhs) {
    return blockRowNo != rhs.blockRowNo || blockColumnNo != rhs.blockColumnNo;
}
Point Block::Iterator::operator*() {
    Point point(block.blockNo, blockRowNo, blockColumnNo);
    return point;
}
Block::Block(const Block& block) :
                grid(block.grid),
                blockNo(block.blockNo) {
}
Block::Block(Grid& grid, int blockNo) :
                grid(grid),
                blockNo(blockNo) {
}
Block& Block::operator=(const Block& block_) {
    grid = block_.grid;
    blockNo = block_.blockNo;
    return *this;
}
Block::Iterator Block::begin() {
    return Iterator(*this, 0, 0);
}
Block::Iterator Block::end() {
    return Iterator(*this, BLOCK_LENGTH, 0);
}

// stringify
string Block::toString() {
    ostringstream ostr;
    ostr << "block (" << blockNo << ")";
    return ostr.str();
}

==============================================
block.h
==============================================
/*
 * block.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef block_H_
#define block_H_
#include "common.h"
#include "cell.h"
#include "grid.h"

class Grid;
class Block {
    Grid& grid;
    int blockNo;
public:
	Block(const Block& block);
	Block(Grid& grid, int blockNo);
	class Iterator: iterator<input_iterator_tag, int> {
	public:
		Block& block;
		int blockRowNo, blockColumnNo;
		Iterator(Block& block, int blockRowNo, int blockColumnNo);
		Iterator(const Iterator& iter);
		Iterator operator++();
		Iterator operator++(int);
		bool operator==(Iterator rhs);
		bool operator!=(Iterator rhs);
		Point operator*();
	};

	Block& operator=(const Block& block);
	Iterator begin();
	Iterator end();
	//Cell& cell(int blockRow, int blockColumn);
	string toString();

};

typedef Block::Iterator BlockIterator;
typedef vector<Block> BlockVector;

#endif /* block_H_ */
==============================================
board.cpp
==============================================
/*
 * board.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include <iomanip>
#include "board.h"

#include "sudokuinit.h"

int Board::idSeq = 0;

Board::Board() :
                nfree(GRID_SIZE),
                lastCellNo(0),
                id(idSeq++) {
}

Board::Board(const Board& board) :
                nfree(board.nfree),
                lastCellNo(0),
                grid(board.grid),
                id(idSeq++) {
}
// find cell that is candidate for having values filled
Cell* Board::nextCell() {
    if (nfree > 0) {
        cout << "Board::nextcell: starting with " << lastCellNo << endl;
        Cell* candidate = NULL;
        for (int next = lastCellNo; next < GRID_SIZE; next++) {
            Cell& cell = grid.cells[next];
            if (!cell.isSet()) {
                cout << "Board::nextCell: cell " << next << " not set" << endl;
                if (candidate == NULL) {
                    candidate = &cell;
                    if (1) { //SudokuInit::debugCell()) {
                        cout << "Board::nextCell: first  " << cell.to_string()
                                << endl;
                    }
                } else {
                    // pick the cell with the fewest available possibilities
                    if (1) { //SudokuInit::debugCell()) {
                        cout << "Board::nextCell: " << cell.to_string()
                                << " not set, no. candidates "
                                << cell.getNAvailableCandidates()
                                << " min so far "
                                << candidate->getNAvailableCandidates() << " "
                                << candidate->to_string() << endl;
                    }
                    if (cell.getNAvailableCandidates()
                            < candidate->getNAvailableCandidates())
                        candidate = &cell;
                }
            } else {
                if (1) //SudokuInit::debugCell()) {
                    cout << "Board::nextCell: " << cell.to_string() << " set"
                            << endl;
            }
        }
        return candidate;
    } else {
        return NULL;
    }
}
bool Board::complete() {
    return (nfree == 0);
}
void Board::print(const char *msg) {
    int idx = 0;
    if (msg != NULL)
        cout << msg << endl;
    cout << endl;
    cout << "id: " << id << " nfree: " << nfree << " lastCellNo: " << lastCellNo
            << endl;
    for (int i = 0; i < BLOCK_LENGTH * BLOCK_LENGTH; i++) {
        if (i % BLOCK_LENGTH == 0)
            cout << " +============+============+============+"
                    << "============+============+============+"
                    << "============+============+============+" << endl
                    << flush;
        else
            cout << " +------------+------------+------------+"
                    << "------------+------------+------------+"
                    << "------------+------------+------------+" << endl
                    << flush;
        int idx_save = idx;
        cout << " #";
        for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++, idx++) {
            cout << dec << setw(6) << grid.cells[idx].getValue() << setw(6)
                    << grid.cells[idx].getCandidates().getNAvailableCandidates()
                    << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
        }
        cout << endl << flush;
        /*
         idx = idx_save;
         cout << " #";
         for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++) {
         cout << setw(6)
         << grid.cells[idx++].getCandidates().getNAvailableCandidates()
         << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
         }
         cout << endl << flush;
         */
        idx = idx_save;
        cout << " #";
        for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++) {
            cout << grid.cells[idx++].getCandidates().to_string()
                    << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
        }
        cout << endl << flush;
    }
    cout << " +============+============+============+"
            << "============+============+============+"
            << "============+============+============+" << endl << flush;
}
void Board::print_short(const char *msg) {
    int idx = 0;
    if (msg != NULL)
        cout << msg << endl;
    cout << endl;
    cout << "id: " << id << " nfree: " << nfree << " lastCellNo: " << lastCellNo
            << endl;
    for (int i = 0; i < BLOCK_LENGTH * BLOCK_LENGTH; i++) {
        if (i % BLOCK_LENGTH == 0)
            cout << " +===+===+===+" << "===+===+===+" << "===+===+===+" << endl
                    << flush;
        else
            cout << " +---+---+---+" << "---+---+---+" << "---+---+---+" << endl
                    << flush;
        int idx_save = idx;
        cout << " #";
        for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++, idx++) {
            cout << dec << setw(3) << grid.cells[idx].getValue()
                    << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
        }
        cout << endl << flush;
        /*
         idx = idx_save;
         cout << " #";
         for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++) {
         cout << setw(6)
         << grid.cells[idx++].getCandidates().getNAvailableCandidates()
         << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
         }
         cout << endl << flush;
         */
        idx = idx_save;
        cout << " #";
        for (int j = 0; j < BLOCK_LENGTH * BLOCK_LENGTH; j++) {
            cout << grid.cells[idx++].getCandidates().to_string()
                    << (j % BLOCK_LENGTH == BLOCK_LENGTH - 1 ? "#" : "|");
        }
        cout << endl << flush;
    }
    cout << " +===+===+===+" << "===+===+===+" << "===+===+===+" << endl
            << flush;
}
void Board::set(int rowNo, int columnNo, int candidate) {
    Point point(rowNo, columnNo);
    set(point, candidate);
}

Cell& Board::getCell(Point& point) {
    return grid.getCell(point);
}
// assign new cell value to board
void Board::set(Point& point, int candidate) {
    Cell& cell = getCell(point);
    if (SudokuInit::debugCell())
        cout << "Board::set " << cell.to_string() << " to value " << candidate
                << " nfree before: " << nfree << endl;
// check if cell value has no value
    if (!cell.isSet()) {
        if (candidate != 0) {
            if (SudokuInit::debugCell())
                cout << "Board::set before " << cell.to_string() << " to value "
                        << candidate << " nfree: " << nfree << endl;
            cell.set(candidate);
            --nfree;
            if (SudokuInit::debugCell())
                cout << "Board::set after  " << cell.to_string() << " nfree: "
                        << nfree << endl;
            Row row(grid, point.getRowNo());
            for (RowIterator iter = row.begin(); iter != row.end(); iter++) {
                Point iterPoint = (*iter);
                Cell& iterCell = getCell(iterPoint);
                if (iterPoint.getColumnNo() != point.getColumnNo()) {
                    if (iterCell.isSet()) {
                        if (SudokuInit::debugCell())
                            cout
                                    << "  Board::set rowNo:    cell already set to "
                                    << " " << iterCell.getValue() << "    "
                                    << iterPoint.to_string() << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    } else {
                        iterCell.getCandidates().removeCandidate(candidate);
                        if (SudokuInit::debugCell())
                            cout << "  Board::set rowNo:    removing candidate "
                                    << candidate << " of "
                                    << iterCell.getCandidates().getNAvailableCandidates()
                                    << " " << iterCell.getPoint().to_string()
                                    << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    }
                } else {
                    if (SudokuInit::debugCell())
                        cout
                                << "  Board::set rowNo:    skipping original point   "
                                << iterCell.getPoint().to_string() << endl;
                }
            }
            Column column = Column::create(grid, point.getColumnNo());
            for (ColumnIterator iter = column.begin(); iter != column.end();
                    iter++) {
                Point iterPoint = (*iter);
                Cell& iterCell = getCell(iterPoint);
                if (iterPoint.getRowNo() != point.getRowNo()) {
                    if (iterCell.isSet()) {
                        if (SudokuInit::debugCell())
                            cout
                                    << "  Board::set columnNo: cell already set to "
                                    << " " << iterCell.getValue() << "    "
                                    << iterPoint.to_string() << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    } else {
                        iterCell.getCandidates().removeCandidate(candidate);
                        if (SudokuInit::debugCell())
                            cout << "  Board::set columnNo: removing candidate "
                                    << candidate << " of "
                                    << iterCell.getCandidates().getNAvailableCandidates()
                                    << " " << iterPoint.to_string() << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    }
                } else {
                    if (SudokuInit::debugCell())
                        cout
                                << "  Board::set columnNo: skipping original point   "
                                << iterPoint.to_string() << endl;
                }
            }
            Block block(grid, point.getBlockNo());
            for (Block::Iterator iter = block.begin(); iter != block.end();
                    iter++) {
                Point iterPoint = (*iter);
                Cell& iterCell = getCell(iterPoint);
                if (iterPoint.getRowNo() != point.getRowNo()
                        || iterPoint.getColumnNo() != point.getColumnNo()) {
                    if (iterCell.isSet()) {
                        if (SudokuInit::debugCell())
                            cout
                                    << "  Board::set block:    cell already set to "
                                    << " " << iterCell.getValue() << "    "
                                    << iterCell.getPoint().to_string() << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    } else {
                        iterCell.getCandidates().removeCandidate(candidate);
                        if (SudokuInit::debugCell())
                            cout << "  Board::set block:    removing candidate "
                                    << candidate << " of "
                                    << iterCell.getCandidates().getNAvailableCandidates()
                                    << " " << iterPoint.to_string() << " "
                                    << iterCell.getCandidates().getAvailableCandidates()
                                    << endl;
                    }
                } else {
                    if (SudokuInit::debugCell())
                        cout
                                << "  Board::set block:    skipping original point   "
                                << iterPoint.to_string() << endl;
                }
            }
        }
    } else {
        cout << "Board::set error: getCell (" << point.getRowNo() << ", "
                << point.getColumnNo() << ") = " << cell.getValue()
                << " being set to " << candidate << endl;
    }
}
// for now, a simple evaluation function: best = less free cells
int Board::value() const {
    return nfree;
}

==============================================
board.h
==============================================
/*
 * board.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef BOARD_H_
#define BOARD_H_
#include "common.h"
#include "block.h"
#include "grid.h"
#include "row.h"
#include "column.h"
#include "cell.h"
#include "boardcomparison.h"

class Board {
private:
    Grid grid;
    // invariant: nfree = no. of unassigned cells
    int nfree;
    int lastCellNo;
    int id;
public:
    static int idSeq;
    Board();
    Board(const Board& board);
    void load(string& file);
    // find cell that is candidate for having values filled
    Cell* nextCell();
    bool complete();
    void print(const char *msg = NULL);
    void print_short(const char *msg);
    void printAvailable();
    void printnAvailableValues();
    // assign new cell value to board
    void set(Point& point, int value);
    // assign new cell value to board
    void set(int rowNo, int columnNo, int value);
    // for now, a simple evaluation function: best = less free cells
    int value() const;
    Cell& getCell(Point& point);
};

typedef vector<Board> BoardList;
typedef priority_queue<Board, BoardList, BoardComparison> BoardPQ;

#endif /* BOARD_H_ */
==============================================
boardcomparison.cpp
==============================================
/*
 * boardcomparison.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "boardcomparison.h"
#include "board.h"

//BoardComparison(const bool& reverse_=PQ_ORDER_ASCENDING) {
BoardComparison::BoardComparison(const bool reverse_) {
	reverse = reverse_;
}
bool BoardComparison::operator()(const Board& lhs, const Board& rhs) const {
	return (reverse ? lhs.value() > rhs.value() : lhs.value() < rhs.value());
}

==============================================
boardcomparison.h
==============================================
/*
 * boardcomparison.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef BOARDCOMPARISON_H_
#define BOARDCOMPARISON_H_

const bool PQ_ORDER_ASCENDING = true;
const bool PQ_ORDER_DESCENDING = false;
// compare board value:
// - reverse = true  -> order increasing
// - reverse = false -> order decreasing
class Board;

class BoardComparison {
	bool reverse;
public:
	BoardComparison(const bool reverse_ = PQ_ORDER_ASCENDING);
	bool operator()(const Board& lhs, const Board& rhs) const;
};

#endif /* BOARDCOMPARISON_H_ */
==============================================
candidates.cpp
==============================================
/*
 * candidates.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "candidates.h"

Candidates::Candidates() :
                availableCandidates(ALL_CANDIDATES_AVAILABLE),
                nAvailableCandidates(GRID_LENGTH) {
}
Candidates::Candidates(int initValue) :
                availableCandidates(initValue),
                nAvailableCandidates(GRID_LENGTH) {
}

// use default base copy Constructor, assignment operator
string Candidates::to_string() {
    return "0x" + availableCandidates.to_string();
}

// set value as not available (presumably set from row, column, box)
bool Candidates::isAvailable(int value) {
    return (availableCandidates[value] != 0);
}

// number of available candidates
int Candidates::getNAvailableCandidates() {
    return nAvailableCandidates;
}

// set value as not available (presumably set from row, column, box)
void Candidates::removeCandidate(int value) {
    //if (value != CELL_NOVALUE)
    if (availableCandidates[value]) {
        --nAvailableCandidates;
        availableCandidates[value] = 0;
    }
}

// set all values as unavailable
void Candidates::removeAllCandidates() {
    nAvailableCandidates = 0;
    availableCandidates = 0;
}

int Candidates::Iterator::operator*() {
    return value;
}

Candidates::Iterator::Iterator(Candidates& candidates, int value) :
                candidates(candidates),
                value(value) {
}
bool Candidates::Iterator::operator==(const Iterator rhs) {
    return value == rhs.value;
}
bool Candidates::Iterator::operator!=(const Iterator rhs) {
    return value != rhs.value;
}
Candidates::Iterator& Candidates::Iterator::operator++() {
    ++value;
    return *this;
}
Candidates::Iterator Candidates::Iterator::operator++(int) {
    Iterator tmp(*this);
    ++value;
    return tmp;
}
Candidates::Iterator Candidates::begin() {
    Candidates::Iterator iterator(*this, 1);
    return iterator;
}

Candidates::Iterator Candidates::end() {
    Candidates::Iterator iterator(*this, GRID_LENGTH+1);
    return iterator;
}

==============================================
candidates.h
==============================================
/*
 * possibilities.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef CANDIDATES_H_
#define CANDIDATES_H_
#include "common.h"

// allow setting to 1:GRID_EXTENT
typedef bitset<CANDIDATE_COUNT> AvailableCandidates;

class Candidates {
private:
    AvailableCandidates availableCandidates;
    // number of values currently available (0:9)
    int nAvailableCandidates;
public:
    // constructor
    Candidates();
    Candidates(int initValue);
    // use default base copy Constructor, assignment operator
    //ValuesAvailable intersect(ValuesAvailable valuesAvailable_);
    string to_string();
    // is value as available?
    bool isAvailable(int candidates);
    // number of available candidates
    int getNAvailableCandidates();
    // set value as not available (presumably set from row, column, box)
    void removeCandidate(int value);
    // cell is set to a value
    void removeAllCandidates();
    // return set of values for e.g. iterating over
    class Iterator;
    Iterator begin();
    Iterator end();

    inline const AvailableCandidates& getAvailableCandidates() const {
        return availableCandidates;
    }
};
// return set of values for e.g. iterating over
class Candidates::Iterator {
    Candidates& candidates;
    int value;
public:
    Iterator(Candidates& candidates, int value);
    Iterator& operator++();
    Iterator operator++(int);
    bool operator==(const Iterator rhs);
    bool operator!=(const Iterator rhs);
    int operator*();
};
#endif /* CANDIDATES_H_ */
==============================================
cell.cpp
==============================================
/*
 * cell.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "cell.h"
/*
 * Cell available values:
 * - valid values are 1..9, 0 = no value
 * - bitmask possibilities_ indicates possible values while no
 *   value set
 */
// constructor: n 0..GRID_AREA-1
Cell::Cell(int index) :
                point(index),
                value(0) {
}
//Cell::Cell(Point point) : point(point) {}
Cell::Cell(const Cell& cell) :
                point(cell.point),
                candidates(cell.candidates),
                value(cell.value) {
}

// cell assigned a value?
bool Cell::isSet() {
    return getNAvailableCandidates() == 0;
}
// set cell to a value
void Cell::set(int value_) {
    setValue(value_);
    candidates.removeAllCandidates();
}

// candidate values
Candidates& Cell::getCandidates() {
    return candidates;
}
// number of free candidates
int Cell::getNAvailableCandidates() {
    return candidates.getNAvailableCandidates();
}
string Cell::to_string() {
    ostringstream ostr;
    ostr << "cell " << point.to_string() << " value " << value << " nvalues "
            << candidates.getNAvailableCandidates() << " hex 0x" << hex
            << candidates.getAvailableCandidates();
    return ostr.str();
}

==============================================
cell.h
==============================================
/*
 * cell.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef CELL_H_
#define CELL_H_
#include "common.h"
#include "point.h"
#include "candidates.h"

/*
 * Cell available values:
 * - valid values are 1..9, 0 = no value
 * - bitmask possibilities_ indicates possible values while no
 *   value set
 */
class Cell {
    Point point;
    Candidates candidates;
    int value;
public:
    Cell(int n);
    Cell(const Cell& cell);
    // cell assigned a value?
    bool isSet();
    // set cell to a value
    void set(int value);
    // candidate values
    Candidates& getCandidates();
    // number of free candidates
    int getNAvailableCandidates();
    // set value as unavailable for cell
    void unavailable(int value_);
    // stringify
    string to_string();

    inline Point& getPoint()  {
        return point;
    }

    inline int getValue() const {
        return value;
    }

    void setCandidates(const Candidates& candidates) {
        this->candidates = candidates;
    }

    void setPoint(const Point& point) {
        this->point = point;
    }

    void setValue(int value) {
        this->value = value;
    }
};

typedef vector<Cell> CellVector;
typedef CellVector::iterator CellVectorIterator;

#endif /* CELL_H_ */
==============================================
column.cpp
==============================================
/*
 * column.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#include "column.h"

Column::Iterator::Iterator(Column& column_, int rowNo_) :
                column(column_),
                rowNo(rowNo_) {
}
Column::Iterator::Iterator(const Iterator& iter) :
                column(iter.column),
                rowNo(iter.rowNo) {
}
Column::Iterator& Column::Iterator::operator++() {
    ++rowNo;
    return *this;
}
Column::Iterator Column::Iterator::operator++(int) {
    Iterator tmp(*this);
    ++rowNo;
    return tmp;
}
bool Column::Iterator::operator==(Iterator rhs) {
    return rowNo == rhs.rowNo;
}
bool Column::Iterator::operator!=(Iterator rhs) {
    return rowNo != rhs.rowNo;
}
Point Column::Iterator::operator*() {
    Point point(rowNo, column.columnNo);
    return point;
}
Column::Column(const Column& column_) :
                grid(column_.grid),
                columnNo(column_.columnNo) {
}
Column::Column(Grid& grid_, int columnNo_) :
                grid(grid_),
                columnNo(columnNo_) {
}
Column create(const Column column_) {
    Column column(column_);
    return column;
}
Column Column::create(Grid& grid_, int columnNo_) {
    return Column(grid_, columnNo_);
}
Column& Column::operator=(const Column& column) {
    grid = column.grid;
    columnNo = column.columnNo;
    return *this;
}
Column::Iterator Column::begin() {
    return Iterator(*this, 0);
}
Column::Iterator Column::end() {
    return Iterator(*this, GRID_LENGTH);
}
Cell& Column::getCell(int rowNo) {
    Point point(rowNo, columnNo);
    return grid.getCell(point);
}
// stringify
string Column::toString() {
    ostringstream ostr;
    ostr << "column (" << columnNo << ")";
    return ostr.str();
}

==============================================
column.h
==============================================
/*
 * column.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef COLUMN_H_
#define COLUMN_H_
#include "common.h"
#include "cell.h"
#include "grid.h"

class Grid;
class Column {
    Grid& grid;
    int columnNo;
public:
    Column(Grid& grid_, int columnNo_);
    Column(const Column& column_);
    class Iterator: iterator<input_iterator_tag, int> {
        Column& column;
        int rowNo;
    public:
        Iterator(Column& column_, int rowNo_);
        Iterator(const Iterator& iter);
        Iterator& operator++();
        Iterator operator++(int);
        bool operator==(Iterator rhs);
        bool operator!=(Iterator rhs);
        Point operator*();
    };
    static Column create(const Column column_);
    static Column create(Grid& grid_, int columnNo_);
    Column& operator=(const Column& column);
    Iterator begin();
    Iterator end();
    Cell& getCell(int rowNo);
    string toString();
};

typedef Column::Iterator ColumnIterator;
typedef vector<Column> ColumnVector;

#endif /* COLUMN_H_ */
==============================================
common.h
==============================================
/*
 * common.h
 *
 *  Created on: Feb 5, 2017
 *      Author: kushn_du3a95r
 */

#ifndef COMMON_H_
#define COMMON_H_

const int CANDIDATE_COUNT = 10;
const int BLOCK_LENGTH = 3;
const int GRID_LENGTH = 9;
const int ALL_CANDIDATES_AVAILABLE = 0x03FE;
const int GRID_SIZE = GRID_LENGTH * GRID_LENGTH;
const unsigned int SETTINGS_COUNT = 2;
const unsigned int SETTINGS_MASK = 0;
const unsigned int SETTINGS_ALL_MASK = (2 << SETTINGS_COUNT) - 1;

#include <algorithm>
#include <bitset>
#include <cstring>
#include <functional>     // greater
#include <fstream>
#include <iostream>
#include <iterator>     // iterator, input_iterator_tag
#include <set>
#include <string>
#include <sstream>
#include <queue>          // priority_queue
#include <vector>

#include "unistd.h"
using namespace std;

#endif /* COMMON_H_ */
==============================================
grid.cpp
==============================================
/*
 * grid.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "grid.h"
// 9x9 grid of cells
Grid::Grid() {
    for (int i = 0; i < GRID_SIZE; i++) {
        cells.push_back(Cell(i));
    }
}
Grid::Grid(const Grid& grid_) {
    for (int i = 0; i < GRID_SIZE; i++) {
        Cell cell(grid_.cells[i]);
        cells.push_back(cell);
    }
}

// return cell by row 0:8, column 0:8 coordinates
Cell& Grid::getCell(Point& point) {
    int index = point.getIndex();
    return cells[index];
}


==============================================
grid.h
==============================================
/*
 * grid.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef GRID_H_
#define GRID_H_

#include "cell.h"
#include "point.h"

// 9x9 grid of cells
//class Index;
class Point;
//class BoxCell;
class Grid {
public:
    CellVector cells;
    Grid();
    Grid(const Grid& grid_);
    // return cell by index 0:63
    //Cell& getCell(const Index& index);
    // return cell by row 0:8, column 0:8 coordinates
    Cell& getCell(Point& point);
    // return cell by box 0:8, boxrow 0:2, boxcolumn 0:2 coordinates
    //Cell& getCell(const BoxCell& boxCell);
};

#endif /* GRID_H_ */
==============================================
main.cpp
==============================================
/*
 * main.cpp
 *
 *  Created on: Feb 3, 2017
 *      Author: kushn_du3a95r
 */
//============================================================================
// Name        : sudoku.cpp
// Author      :
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================
#include "sudoku.h"
#include "cell.h"
#include "row.h"
#include "sudokuinit.h"

int main(int argc, char **argv) {
    SudokuCallback sudokuCallback;
    Sudoku sudoku(sudokuCallback);
    if (SudokuInit::debugBoard())
        cout << "main: init" << endl;
    sudoku.init(argc, argv);
    /*
     * algorithm:
     * - take the starting board
     * - pick the empty cell with the fewest possible values -- many ties
     * - for its row, column, and box, add the total of filled cells
     *   to break the ties
     * - for each possibility of the empty cell, create a new board
     *   with that value filled in, and put it in a queue ordered by
     *   the total number of cells filled in
     * - take the next board off the queue, and process as above if
     *   the board is not complete.
     */
    if (SudokuInit::debugBoard())
        cout << "main: process" << endl;
    sudoku.process();
    return 0;
}

==============================================
point.cpp
==============================================
#include "point.h"

// grid (row 0:8, column 0:8) coordinates
// private base constructor
Point::Point(int rowNo, int columnNo) :
                rowNo(rowNo),
                columnNo(columnNo) {
    initBlock(rowNo, columnNo);
}

// convert (block 0:8, blockrow 0:2, blockcolumn 0:2) to
// grid (row 0:8, column 0:8) coordinates
Point::Point(int blockNo, int blockRowNo, int blockColumnNo) :
                blockNo(blockNo),
                blockRowNo(blockRowNo),
                blockColumnNo(blockColumnNo) {
    // convert block coordinate (0:8) to block offsets (0:2, 0:2)
    int xBoxOffset = blockNo % BLOCK_LENGTH;
    int yBoxOffset = blockNo / BLOCK_LENGTH;
    // get 3x3 block upper left-hand corners (0:6, 0:6)
    int xBoxUlc = xBoxOffset * BLOCK_LENGTH;
    int yBoxUlc = yBoxOffset * BLOCK_LENGTH;
    // convert to (0:8, 0:8) grid coordinates
    rowNo = yBoxUlc + blockRowNo;
    columnNo = xBoxUlc + blockColumnNo;
    index = rowNo * GRID_LENGTH + columnNo;
}
/*
Point Point::create(int blockNo, int blockRowNo, int blockColumnNo) {
    Point point(int blockNo, int blockRowNo, int blockColumnNo);
    return point;
}
*/
// convert (index 0:80) to
// grid (row 0:8, column 0:8) coordinates
Point::Point(int index) :
                index(index) {
    rowNo = (index / GRID_LENGTH);
    columnNo = (index % GRID_LENGTH);
    initBlock(rowNo, columnNo);
}
void Point::initBlock(int rowNo, int columnNo) {
// the (row, column) to box mapping is:
    blockNo = (rowNo / BLOCK_LENGTH) * BLOCK_LENGTH + columnNo / BLOCK_LENGTH;
// get 3x3 box offsets  (0:2, 0:2)
    blockRowNo = rowNo % BLOCK_LENGTH;
    blockColumnNo = columnNo % BLOCK_LENGTH;
}
const int Point::getIndex() {
    return rowNo * GRID_LENGTH + columnNo;
}
// stringify
string Point::to_string() {
    ostringstream ostr;
    ostr << "(" << rowNo << ", " << columnNo << ")";
    return ostr.str();
}
==============================================
point.h
==============================================
/*
 * point.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef POINT_H_
#define POINT_H_
#include "common.h"

// grid (row 0:8, column 0:8) coordinates
class Block;
class Point {
    int rowNo;
    int columnNo;
    int blockNo;
    int blockRowNo;
    int blockColumnNo;
    int index;
public:
    // private base constructor
    Point(int rowNo, int columnNo);
    // convert (box 0:8, blockRowNo 0:2, blockColumnNo 0:2) to
    // grid (row 0:8, column 0:8) coordinates
    Point(int blockNo, int blockRowNo, int blockColumnNo);
    Point(Block& block, int blockRowNo, int blockColumnNo);
    // convert (index 0:80) to
    // grid (row 0:8, column 0:8) coordinates
    Point(int index);
    void initBlock(int rowNo, int columnNo);
    const int getIndex();

    // stringify
    string to_string();

    inline int getColumnNo() const {
        return columnNo;
    }

    inline int getRowNo() const {
        return rowNo;
    }

    inline int getBlockNo() const {
        return blockNo;
    }
};

#endif /* POINT_H_ */
==============================================
row.cpp
==============================================
/*
 * row.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "row.h"

Row::Iterator::Iterator(Row& row, int columnNo) :
                row(row),
                columnNo(columnNo) {
}
Row::Iterator::Iterator(const Iterator& iter) :
                row(iter.row),
                columnNo(iter.columnNo) {
}
Row::Iterator& Row::Iterator::operator++() {
    ++columnNo;
    return *this;
}
Row::Iterator Row::Iterator::operator++(int) {
    Iterator tmp(*this);
    ++columnNo;
    return tmp;
}
bool Row::Iterator::operator==(const Iterator rhs) {
    return columnNo == rhs.columnNo;
}
bool Row::Iterator::operator!=(const Iterator rhs) {
    return columnNo != rhs.columnNo;
}
Point Row::Iterator::operator*() {
    Point point(row.rowNo, columnNo);
    return point;
}
Row::Row(const Row& row) :
                grid(row.grid),
                rowNo(row.rowNo) {
}
Row::Row(Grid& grid, int rowNo) :
                grid(grid),
                rowNo(rowNo) {
}
Row& Row::operator=(const Row& row) {
    grid = row.grid;
    rowNo = row.rowNo;
    return *this;
}
Row::Iterator Row::begin() {
    return Iterator(*this, 0);
}
Row::Iterator Row::end() {
    return Iterator(*this, GRID_LENGTH);
}
Cell& Row::getCell(int columnNo) {
    Point point(rowNo, columnNo);
    return grid.getCell(point);
}
// stringify
string Row::toString() {
    ostringstream ostr;
    ostr << "row (" << rowNo << ")";
    return ostr.str();
}
==============================================
row.h
==============================================
/*
 * row.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef ROW_H_
#define ROW_H_
#include "common.h"
#include "cell.h"
#include "grid.h"

class Row {
    Grid& grid;
    int rowNo;
public:
    Row(Grid& grid, int rowNo);
	Row(const Row& row);
	class Iterator: iterator<input_iterator_tag, int> {
	public:
		Row& row;
		int columnNo;
		Iterator(Row& row, int columnNo);
		Iterator(const Iterator& iter);
		Iterator& operator++();
		Iterator operator++(int);
		bool operator==(const Iterator rhs);
		bool operator!=(const Iterator rhs);
		Point operator*();
	};
	Row& operator=(const Row& row_);
	Iterator begin();
	Iterator end();
	Cell& getCell(int columnNo);
	string toString();
};

typedef Row::Iterator RowIterator;
typedef vector<Row> RowVector;

#endif /* ROW_H_ */
==============================================
sudoku.cpp
==============================================
//============================================================================
// Name        : sudoku.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include "sudoku.h"

// initialize board with numbers
// initialize priority queue with board(evaluation function)
// while (!empty of priority queue)
//   board = priority queue.pop()
//   if (board.complete())
//     board.print();
//     if (first_only)
//       break
//   else
//     next_cell = board.nextCell()
//     new_possibilities = next_cell.possibilities()
//     for (iter = new_possibilities.begin();
//          iter != new_possibilities.end();
//          iter++)
//       new_board = Board(board).add(*iter)

Sudoku::Sudoku(SudokuCallback& sudokuCallback) :
                sudokuCallback(sudokuCallback) {
}

void Sudoku::init(int argc, char **argv) {
    sudokuInit.parseArgs(argc, argv);
    Board board;
    sudokuInit.readBoard(board);
    if (SudokuInit::debugBoard())
        cout << "Sudoku::init: push board " << endl;
    pq.push(board);
}

void Sudoku::process() {
    if (SudokuInit::debugBoard())
        cout << "Sudoku::process: test empty " << endl;
    while (!pq.empty()) {
        if (SudokuInit::debugBoard())
            cout << "Sudoku::process: not empty " << endl;
        Board nextBoard = pq.top();  // Print highest priority board
        pq.pop();  // Remove highest priority board
        if (SudokuInit::debugBoard())
            nextBoard.print("Sudoku::process: next highest priority board");
        if (nextBoard.complete()) {
            if (1)//(SudokuInit::debugBoard())
                nextBoard.print_short("Sudoku::process: board complete");
            break; // assume only one solution, or others are reflections
        } else {
            Cell* nextCell = nextBoard.nextCell();
            if (1)//(SudokuInit::debugCell())
                cout << endl << "Sudoku::process trying next cell: "
                        << (nextCell == NULL ? "NULL" : nextCell->to_string())
                        << endl;
            if (nextCell == NULL) {
                cout << "Sudoku::process error getting next cell" << endl;
            } else {
                Point& point = nextCell->getPoint();
                Candidates& candidates = nextCell->getCandidates();
                cout << "Sudoku::process candidates " << candidates.to_string() << endl;
                for (Candidates::Iterator iter = candidates.begin();
                        iter != candidates.end(); iter++) {
                    int candidate = *iter;
                    cout << "Sudoku::process  looking at candidate "
                            << candidate << endl;
                    if (candidates.isAvailable(candidate)) {
                        cout << "Sudoku::process setting candidate "
                                << candidate << " of " << nextCell->to_string()
                                << endl;
                        Board candidateBoard(nextBoard);
                        candidateBoard.set(point, candidate);
                        if (SudokuInit::debugBoard())
                            candidateBoard.print();
                        pq.push(candidateBoard);
                    } else {
                        cout << "Sudoku::process  candidate " << candidate
                                << " unavailable" << endl;

                    }
                }
            }
        }
    }
    if (SudokuInit::debugBoard())
        cout << "Sudoku::process: empty " << endl;

}
==============================================
sudoku.h
==============================================
/*
 * sudoku.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef SUDOKU_H_
#define SUDOKU_H_

#include "common.h"
#include "board.h"
#include "cell.h"
#include "row.h"
#include "sudokucallback.h"
#include "sudokuinit.h"

using namespace std;

class Sudoku {
private:
    SudokuCallback& sudokuCallback;
    SudokuInit sudokuInit;

    //BoardPQ pq(PQ_ORDER_ASCENDING);
    BoardPQ pq;
public:
    Sudoku();
    Sudoku(SudokuCallback& sudokuCallback);

    void init(int argc, char **argv);
    void process();
};

#endif /* SUDOKU_H_ */

==============================================
sudokucallback.cpp
==============================================
//============================================================================
// Name        : sudoku.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include "sudoku.h"
#include "sudokucallback.h"

void SudokuCallback::cellChanged(Cell& oldCell, Cell& newCell) {
    cout << "SudokuCallback::cellChanged:" << endl << "    oldCell: " << oldCell.to_string()
            << endl << "    newCell: " << newCell.to_string() << endl;
}
void SudokuCallback::boardCompleted(Board& board) {
    cout << "SudokuCallback::boardCompleted:" << endl;
    board.print("completed");
}
==============================================
sudokucallback.h
==============================================
/*
 * sudokucallback.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef SUDOKUCALLBACK_H_
#define SUDOKUCALLBACK_H_

#include "board.h"
#include "cell.h"

class SudokuCallback {
public:
    void cellChanged(Cell& oldCell, Cell& newCell);
    void boardCompleted(Board& board);
};

#endif /* SUDOKUCALLBACK_H_ */

==============================================
sudokuinit.cpp
==============================================
/*
 * sudokuparse.cpp
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */
#include "sudokuinit.h"

bool SudokuInit::debugCell() {
    return 1;//settings[DEBUG_CELL_SET];
}

bool SudokuInit::debugBoard() {
    return 1;//settings[DEBUG_BOARD_SET];
}

bitset<SETTINGS_COUNT> SudokuInit::settings = 3;

void SudokuInit::parseArgs(int argc, char **argv) {
    file = "sudoku.txt";

    //getcwd(dir, 1000);
    for (int arg = 1; arg < argc; arg++) {
        cout << "arg " << arg << " = " << argv[arg] << endl;
        if (!strcmp(argv[arg], "-dc")) {
            settings[DEBUG_CELL_SET] = 1;
        } else if (!strcmp(argv[arg], "-db")) {
            settings[DEBUG_BOARD_SET] = 1;
        } else {
            file = argv[arg];
        }
    }
}

//  parse suduko input file:
//    0 0 0   1 1 1   1 2 2
//  0123456789012345678901234
// 0+-------+-------+-------+
//01| 2 . 6 | 1 . 7 | 4 . 8 |
//02| 3 7 . | . 4 . | . 5 6 |
//03| . 1 . | . 8 . | . 3 . |
// 4+-------+-------+-------+
//05| . 8 3 | 9 . 2 | 5 6 . |
//06| 5 . 4 | 3 6 1 | 7 . 2 |
//07| . . . | 8 . 4 | . . . |
// 8+-------+-------+-------+
//09| 8 . 1 | . . . | 6 . 9 |
//00| . . . | 6 . 8 | . . . |
//11| 7 6 . | 4 9 3 | . 2 1 |
// 2+-------+-------+-------+
void SudokuInit::readBoard(Board& board) {
    ifstream myfile;
    file = "sudoku.txt";

    myfile.open(file.c_str());
    string line;
    int columns[GRID_LENGTH] = { 2, 4, 6, 10, 12, 14, 18, 20, 22 };
    if (debugCell())
        board.print("SudokuInit::readBoard grid before parsing file");
    for (int lineNo = 0, rowNo = 0; lineNo < 13; lineNo++) {
        getline(myfile, line);
        /*
         if (strlen(line) > 22)
         throw new Exception("line too long");
         */
        if (lineNo % 4 != 0) { // lineNo not in (0, 4, 8, 12)
            if (debugCell())
                cout << "SudokuInit::readBoard line " << lineNo << " rowNo "
                        << rowNo << ": " << line << endl;
            for (int columnNo = 0; columnNo < GRID_LENGTH; columnNo++) {
                if (debugCell())
                    cout << "SudokuInit::readBoard     column " << columnNo
                            << " offset " << std::dec << columns[columnNo]
                            << ": " << line[columns[columnNo]] << " (row "
                            << rowNo << ", column " << columnNo << ")" << endl;
                char val = line[columns[columnNo]];
                if (val != '.') {
                    board.set(rowNo, columnNo, (int) val - (int) '0');
                    if (debugBoard())
                        board.print();
                }
            }
            rowNo++;
        }
    }
    myfile.close();
    if (debugBoard())
        board.print("SudokuInit::readBoard");
}

==============================================
sudokuinit.h
==============================================
/*
 * sudokuparse.h
 *
 *  Created on: Feb 24, 2016
 *      Author: Todd
 */

#ifndef SUDOKUINIT_H_
#define SUDOKUINIT_H_

#include "common.h"
#include "board.h"
using namespace std;

class Board;
class SudokuInit {
public:
    string file;
    enum Settings {
        DEBUG_CELL_SET, DEBUG_BOARD_SET
    };
    static bitset<SETTINGS_COUNT> settings;

    void parseArgs(int argc, char **argv);
    void readBoard(Board& board);
    static bool debugCell();
    static bool debugBoard();
};

#endif /* SUDOKUINIT_H_ */
